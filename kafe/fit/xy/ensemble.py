import numpy as np
import scipy.stats
import six

from ...core.error import CovMat
from .._base import FitEnsembleBase, FitEnsembleException
from .cost import XYCostFunction_Chi2
from .fit import XYFit

import matplotlib as mpl
from matplotlib import pyplot as plt
from matplotlib import gridspec as gs


__all__ = ["XYFitEnsemble"]


def _heuristic_optimal_subplot_grid_size(n_subplots, aspect_ratio_priority=0.5):
    def f2(s, k):
        if n_subplots > s * (s + k):
            return 100000
        return ((s * (s + k) - n_subplots) ** 2 * (1.0 - aspect_ratio_priority)
                + (float(k) / float(s)) ** 2 * (aspect_ratio_priority))

    _optimal_f = np.inf
    _optimal_sk = n_subplots, 0
    for s in six.moves.range(1, n_subplots):
        for k in six.moves.range(0, n_subplots):
            _f = f2(s, k)
            if _f < _optimal_f:
                _optimal_f = _f
                _optimal_sk = s, k

    s, k = _optimal_sk
    return s, s+k


def _mean_error(array, axis, *args, **kwargs):
    """Return the standard error of the mean; standard deviation/sqrt(N)"""
    return np.std(array, axis=axis, *args, **kwargs) / np.sqrt(array.shape[axis])

def _mean_pull(array, axis, expected_mean=0.0, expected_standard_deviation=1.0, *args, **kwargs):
    """Return the deviation of the sample mean from the expected mean, normalized
    to the standard error of the mean; standard deviation/sqrt(N)"""
    _expected_mean_errors = expected_standard_deviation / np.sqrt(array.shape[axis])
    _observed_means = np.mean(array, axis=axis) - expected_mean
    return (_observed_means - expected_mean)/_expected_mean_errors


class XYFitEnsembleException(FitEnsembleException):
    pass

class XYFitEnsemble(FitEnsembleBase):
    """
    Object for generating ensembles of fits to *xy* pseudo-data generated according to the
    specified uncertainty model.

    After constructing an :py:obj:`~kafe.fit.XYFitEnsemble` object, an error model should be added
    to it. This is done as for :py:obj:`~kafe.fit.XYFit` objects by using the
    :py:meth:`~kafe.fit.XYFitEnsemble.add_simple_error` or :py:meth:`~kafe.fit.XYFitEnsemble.add_matrix_error`
    methods.

    Once an uncertainty model is provided, the fit ensemble can be generated by using the
    :py:meth:`~kafe.fit.XYFitEnsemble.run` method. This method starts by generating a pseudo-dataset in such a way
    that the empirical distribution of the data corresponds to the specified uncertainty model. It then
    fits the model to the pseudo-data and extracts information from the fit, such as the resulting parameter
    values or the value of the cost function at the minimum. This is repeated a large number of times
    in order to evaluate the whole ensemble in a statistically meaningful way.

    The ensemble result can be visualized by using the :py:meth:`~kafe.fit.XYFitEnsemble.plot_results` method.

    .. TODO Expand section
    """
    FIT_TYPE = XYFit

    AVAILABLE_RESULTS = {'parameter_pulls', 'y_data_pulls', 'cost'}
    _DEFAULT_STATISTICS = {'mean', 'std', 'skew'}
    STATISTICS_FUNCTIONS = {'mean': np.mean,
                            'mean_error': _mean_error,
                            'mean_pull': _mean_pull,
                            'std': np.std,
                            'skew': scipy.stats.skew,
                            'kurtosis': scipy.stats.kurtosis}

    _DEFAULT_PLOT_PDF_KWARGS = dict(marker='')
    _DEFAULT_PLOT_EXPECTED_MEAN_KWARGS = dict(linewidth=1, marker='', linestyle='--',
                                              # use second color in default color cycle
                                              color=mpl.rcParams['axes.prop_cycle'].by_key()['color'][1])
    _DEFAULT_PLOT_OBSERVED_MEAN_KWARGS = dict(linewidth=1, marker='', color='k')
    _DEFAULT_PLOT_ONE_SIGMA_BAND_MEAN_KWARGS = dict(color='k', alpha=0.1)

    def __init__(self, n_experiments, x_support, model_function, model_parameters,
                 cost_function=XYCostFunction_Chi2(axes_to_use='y', errors_to_use='covariance')):
        """
        Construct an :py:obj:`~kafe.fit.XYFitEnsemble` object.

        :param n_experiments: number of pseudoexperiments to perform
        :type n_experiments: int
        :param x_support: *x* values to use as support for calculating the "true" model ("true" *x*)
        :type x_support: iterable of float
        :param model_function: the model function
        :type model_function: :py:class:`~kafe.fit.indexed.XYModelFunction` or unwrapped native Python function
        :param model_parameters: parameters of the "true" model
        :type model_parameters: iterable of float
        :param cost_function: the cost function
        :type cost_function: :py:class:`~kafe.fit._base.CostFunctionBase`-derived or unwrapped native Python function
        """
        self._n_exp = n_experiments
        self._x_support = np.asarray(x_support, dtype=float)
        self._model_parameters = np.asarray(model_parameters)
        self._n_par = len(self._model_parameters)

        # need some dummy initial data values in order to initialize a Fit object
        _dummy_y_data = model_function(x_support, *model_parameters)

        # initialize Fit object used for fitting the pseudo-data
        self._toy_fit = XYFit(xy_data=[x_support, _dummy_y_data],
                              model_function=model_function,
                              cost_function=cost_function)

        self._ref_y_data = self._toy_fit.eval_model_function(x=self._x_support,
                                                             model_parameters=self._model_parameters)

        self._requested_results = {'parameter_pulls', 'y_data_pulls', 'cost'}

        _unavailable_results = set(self._requested_results) - self.AVAILABLE_RESULTS
        if _unavailable_results:
            raise ValueError("Requested unavailable test statistics: %r"
                             % (_unavailable_results,))

        self._initialize_result_arrays()


    def _generate_pseudodata(self):
        """generate new pseudo-data according to fit error model and commit to data container"""

        if not self._toy_fit.has_data_errors:
            raise FitEnsembleException("Cannot generate fit ensemble data: no data error model declared!")

        # -- generate 'x' data
        _x_data = self._x_support

        if self._toy_fit._data_container.has_x_errors:
            _x_data_error = self._toy_fit.x_total_error
            _x_jitter = np.random.normal(np.zeros_like(_x_data, dtype=float), _x_data_error)

            _x_cov_mat = CovMat(self._toy_fit.x_total_cov_mat)  # need cholesky decomposition from CovMat object
            _x_cholesky_l = _x_cov_mat.chol
            if _x_cholesky_l is None:
               raise XYFitEnsembleException("Cannot generate pseudo-data: The total 'x' covariance matrix is not positive definite!")
            _x_lu = _x_cholesky_l.dot(np.matrix(np.diag(np.diag(_x_cholesky_l))).I)
            _x_jitter = np.array(_x_lu).dot(_x_jitter)
            _x_data += _x_jitter

        _y_data = self._toy_fit.eval_model_function(x=_x_data,
                                                    model_parameters=self._model_parameters)
        _y_data_error = self._toy_fit.y_total_error

        # smear y data according to the total 'y' covariance matrix
        # TODO: only gaussian smearing is implemented -> more?
        _y_jitter = np.random.normal(np.zeros_like(_y_data), _y_data_error)

        _y_cov_mat = CovMat(self._toy_fit.y_total_cov_mat)  # need cholesky decomposition from CovMat object
        _y_cholesky_l = _y_cov_mat.chol
        if _y_cholesky_l is None:
           raise XYFitEnsembleException("Cannot generate pseudo-data: The total 'y' covariance matrix is not positive definite!")
        _y_lu = _y_cholesky_l.dot(np.matrix(np.diag(np.diag(_y_cholesky_l))).I)
        _y_jitter = np.array(_y_lu).T.dot(_y_jitter)
        _y_data += _y_jitter

        # update toy fit data container
        self._toy_fit._data_container.x = _x_data
        self._toy_fit._data_container.y = _y_data

    def _gather_results_from_toy_fit(self, i_exp):
        for _stat_name in self._requested_results:
            self._result_array_dicts[_stat_name][i_exp] = self._get_stat(_stat_name)

    def _do_toy_fit(self):
        """run fit with current pseudo-data"""
        self._toy_fit.do_fit()

    def _get_stat_shape_spec(self, stat_name):
        """get the required shape for the test statistic array"""
        _shape = (self.n_exp,)
        _prop_shapes = self.RESULTS_SHAPE_SPECS[stat_name]
        if _prop_shapes is None:
            return _shape
        for _prop in _prop_shapes:
            _shape += (_prop.fget(self),)
        return _shape

    def _get_stat(self, stat_name):
        """get the value of the test statistics for the current fit"""
        return self.RESULTS_PROPERTIES[stat_name].fget(self)

    def _initialize_result_arrays(self):
        """initialize the a"""
        self._result_array_dicts = {}
        for _stat_name in self._requested_results:
            _shape = self._get_stat_shape_spec(_stat_name)
            self._result_array_dicts[_stat_name] = np.zeros(_shape)

    def _make_figure_gs(self, figsize=(8, 8), nrows=1, ncols=1,
                        left=0.1, bottom=0.1,
                        right=0.9, top=0.9):
        """create a new matplotlib figure with a GridSpec controlling the subplot layout"""
        _fig = plt.figure(figsize=figsize)  # defaults from matplotlibrc
        _gs = gs.GridSpec(nrows=nrows,
                          ncols=ncols,
                          left=left,
                          bottom=bottom,
                          right=right,
                          top=top,
                          wspace=None,
                          hspace=None,
                          height_ratios=None)
        return _fig, _gs

    def _init_results_plot_config_dicts(self):
        """initialize the configuration dictionaries relevant for plotting"""
        self._plot_config_dicts = {_result: dict() for _result in self._requested_results}
        self._plot_config_dicts['parameter_pulls'].update(
            dict(stat_name="parameter_pulls",  # FIXME: get automatically
                 stat_name_formatted="parameter_pulls",  # FIXME: get automatically
                 plot_xrange=(-3, 3),
                 plot_xlabel=["Pull ${}$".format(_arg_formatter.latex_name) for _arg_formatter in self._toy_fit._model_function.argument_formatters],
                 plot_label="{} pseudoexperiments".format(self.n_exp),
                 plot_hist_nbins=51,
                 plot_prob_density_label="expected density",
                 plot_prob_density=scipy.stats.norm,
                 plot_prob_density_pars=dict(loc=0, scale=1),
                 plot_expected_mean=0.0,
                 plot_expected_mean_error=1.0/np.sqrt(self.n_exp)))
        self._plot_config_dicts['y_data_pulls'].update(
            dict(stat_name="y_data_pulls",  # FIXME: get automatically
                 stat_name_formatted="y_data_pulls",  # FIXME: get automatically
                 plot_xrange=(-3, 3),
                 plot_xlabel=['Pull $y_{%d}$' % (_i,) for _i in six.moves.range(self.n_dat)],
                 plot_label="{} pseudoexperiments".format(self.n_exp),
                 plot_hist_nbins=51,
                 plot_prob_density_label="expected density",
                 plot_prob_density=scipy.stats.norm,
                 plot_prob_density_pars=dict(loc=0, scale=1),
                 plot_expected_mean=0.0,
                 plot_expected_mean_error=1.0/np.sqrt(self.n_exp)))
        self._plot_config_dicts['cost'].update(
            dict(stat_name="cost",  # FIXME: get automatically
                 stat_name_formatted="cost",  # FIXME: get automatically
                 plot_xrange=(0, 3*self.n_df),
                 plot_xlabel="${}$".format(self._toy_fit._cost_function.formatter.latex_name),
                 plot_label="{} pseudoexperiments".format(self.n_exp),
                 plot_hist_nbins=51,
                 plot_prob_density_label="expected density",
                 plot_prob_density=scipy.stats.chi2,  # FIXME: assume chi2 for all cost functions -> change
                 plot_prob_density_pars=dict(loc=0, df=self.n_df),
                 plot_expected_mean=self.n_df))

    @staticmethod
    def _plot_hist(axes, data, **plot_config):
        """plot a histogram for a result variable, taking the plot configuration dictionaries into account"""
        _stat_name = plot_config.get('stat_name', None)
        _stat_name_formatted = plot_config.get('stat_name_formatted', None)
        _xrange = plot_config.get('plot_xrange', None)
        _xlabel = plot_config.get('plot_xlabel', None)
        _label = plot_config.get('plot_label', None)
        _nbins = plot_config.get('plot_hist_nbins', None)
        _pdf = plot_config.get('plot_prob_density', None)
        _pdf_params = plot_config.get('plot_prob_density_pars', None)
        _pdf_label = plot_config.get('plot_prob_density_label', None)
        _expected_mean = plot_config.get('plot_expected_mean', None)
        _expected_mean_error = plot_config.get('plot_expected_mean_error', None)

        _bin_contents, _bin_edges, _ = axes.hist(data, bins=_nbins, range=_xrange, label=_label)

        if _expected_mean is not None:
            # only show observed mean if expected mean is requested/available
            _observed_mean = np.mean(data)

            _observed_mean_pull = None
            if _expected_mean_error:
                _observed_mean_pull = (_observed_mean - _expected_mean)/_expected_mean_error

            axes.annotate(r"$\mu={}$".format(round(_observed_mean, 2)),
                          xycoords='data',
                          xy=(_observed_mean, 0),
                          textcoords='offset points',
                          xytext=(0, 25),
                          fontsize=12,
                          horizontalalignment='center',
                          verticalalignment='bottom',
                          arrowprops=dict(facecolor='k', shrink=.0)
            )
            if _expected_mean_error:
                axes.annotate(r"$({:+.2f}\sigma)$".format(round(_observed_mean_pull, 2)),
                              xycoords='data',
                              xy=(_observed_mean, 0),
                              textcoords='offset points',
                              xytext=(0, 40),
                              fontsize=12,
                              horizontalalignment='center',
                              verticalalignment='bottom',
                              arrowprops=dict(arrowstyle='-')
                )

        axes.yaxis.set_ticks([])  # don't show y ticks

        if _xrange is not None:
            axes.set_xlim(_xrange)

        if _pdf is not None:
            if _pdf_params is None:
                raise XYFitEnsembleException("PDF '%s' specified for result '%s', but no parameters given!"
                                             % (_pdf.__name__, _stat_name))

            # calculate normalization
            _mean_bin_width = np.mean(_bin_edges[1:] - _bin_edges[:-1])
            _n_entries = np.sum(_bin_contents)
            _plot_prob_density_scale = _mean_bin_width * _n_entries

            _pdf_x_support = np.linspace(*axes.get_xlim(), num=50)   # TODO: config entry for 'num'
            _pdf_y = _plot_prob_density_scale * _pdf.pdf(_pdf_x_support, **_pdf_params)
            axes.plot(_pdf_x_support, _pdf_y, label=_pdf_label, **XYFitEnsemble._DEFAULT_PLOT_PDF_KWARGS)

        if _expected_mean is not None:
            axes.axvline(_expected_mean, label="expected mean", **XYFitEnsemble._DEFAULT_PLOT_EXPECTED_MEAN_KWARGS)
            if _expected_mean_error:
                axes.axvspan(_expected_mean-_expected_mean_error, _expected_mean+_expected_mean_error,
                             label="standard error of the mean",
                             **XYFitEnsemble._DEFAULT_PLOT_ONE_SIGMA_BAND_MEAN_KWARGS)

        if _xlabel is not None:
            axes.set_xlabel(_xlabel)


    # -- private properties

    @property
    def _parameter_pulls(self):
        """property for fit variable 'parameter_pulls'"""
        return (self._toy_fit.parameter_values - self._model_parameters)/self._toy_fit.parameter_errors

    @property
    def _y_data_pulls(self):
        """property for fit variable 'y_data_pulls'"""
        return (self._toy_fit.y_data - self._toy_fit.y_model)/self._toy_fit.y_total_error

    @property
    def _cost(self):
        """property for fit variable 'cost'"""
        return self._toy_fit.cost_function_value


    # -- public properties

    @property
    def n_exp(self):
        """the number of pseudo-experiments to perform"""
        return self._n_exp

    @property
    def n_par(self):
        """the number of parameters"""
        return self._n_par

    @property
    def n_dat(self):
        """the number of degrees of freedom for the fit"""
        return self._toy_fit._data_container.size

    @property
    def n_df(self):
        """the number of degrees of freedom for the fit"""
        # FIXME: not generally true -> update to handle constrained parameters
        # TODO: not applicable for all cost functions -> find a flexible solution
        return self.n_dat - self.n_par

    # -- public methods

    def add_simple_error(self, axis, err_val, correlation=0, relative=False):
        self._toy_fit.add_simple_error(axis=axis, err_val=err_val, correlation=correlation, relative=relative)

    # "inherit" docstring
    add_simple_error.__doc__ = XYFit.add_simple_error.__doc__

    def add_matrix_error(self, axis, err_matrix, matrix_type, err_val=None, relative=False):
        self._toy_fit.add_matrix_error(axis=axis, err_matrix=err_matrix, matrix_type=matrix_type, err_val=err_val, relative=relative)

    # "inherit" docstring
    add_matrix_error.__doc__ = XYFit.add_matrix_error.__doc__

    def run(self):
        """Perform the pseudo-experiments. Retrieve and store the requested fit result variables."""
        self._initialize_result_arrays()
        for _i_exp in six.moves.range(self.n_exp):
            self._generate_pseudodata()
            self._do_toy_fit()
            self._gather_results_from_toy_fit(_i_exp)

    def get_results_statistics(self, results='all', statistics='all'):
        """
        Return a dictionary containing ...

        :param results: names of retrieves fit variable for which to return statistics
        :type results: iterable of str or ``'all'`` (get statistics for all retrieved variables)
        :return: dict
        """
        if results == 'all':
            results = self._requested_results

        if statistics == 'all':
            statistics = self.__class__._DEFAULT_STATISTICS

        _dict_to_return = dict()
        for _result_name in results:
            _result_array = self._result_array_dicts.get(_result_name, None)
            _current_result_dict = _dict_to_return[_result_name] = dict()

            # calculate and store statistics
            for _stat_name in statistics:
                _stat = self.__class__.STATISTICS_FUNCTIONS.get(_stat_name, None)
                if _stat is None:
                    raise FitEnsembleException(
                        "Unknown statistic '%s' requested!" % (_stat_name,))
                _stat = _stat(_result_array, axis=0)
                _current_result_dict[_stat_name] = _stat

        return _dict_to_return

    def plot_results(self, results='all',
                     show_legend=True):
        """
        Make plots with histograms of the requested fit variable values across all pseudo-experiments.

        :param results: names of retrieved fit variable for which to generate plots
        :type results: iterable of str or ``'all'`` (make plots for all retrieved variables)
        :param show_legend: if ``True``, show a plot legend on each figure
        :type show_legend: bool
        """
        if results == 'all':
            results = self._requested_results

        self._init_results_plot_config_dicts()

        for _result_name in results:
            _result_array = self._result_array_dicts.get(_result_name, None)
            _plot_config = self._plot_config_dicts[_result_name].copy()

            _all_legend_handles = tuple()
            _all_legend_labels = tuple()
            if _result_array is None:
                raise FitEnsembleException("Cannot plot result for variable '%s': variable not collected!" % (_result_name,))

            if _result_array.ndim == 1:
                _fig, _gs = self._make_figure_gs(figsize=(8, 8), nrows=1, ncols=1)
                _ax = plt.subplot(_gs[0, 0])
                self._plot_hist(_ax, _result_array, **_plot_config)

                # keep track of subplot legend handles/labels
                if show_legend:
                    _hs, _ls = _ax.get_legend_handles_labels()
                    _all_legend_handles += tuple(_hs)
                    _all_legend_labels += tuple(_ls)

            elif _result_array.ndim == 2:
                _nplots = int(_result_array.shape[1])
                _nrows, _ncols = _heuristic_optimal_subplot_grid_size(_nplots, aspect_ratio_priority=0.8)
                _fig, _gs = self._make_figure_gs(figsize=(8, 8), nrows=_nrows, ncols=_ncols)
                for _i_plot in six.moves.range(_nplots):
                    _plot_config_subplot = _plot_config.copy()
                    _plot_config_subplot['plot_xlabel'] = _plot_config_subplot['plot_xlabel'][_i_plot]
                    _row = int(_i_plot/_ncols)
                    _col = _i_plot % _ncols
                    _ax = plt.subplot(_gs[_row, _col])
                    self._plot_hist(_ax, _result_array[:, _i_plot], **_plot_config_subplot)

                    # keep track of subplot legend handles/labels
                    if show_legend:
                        _hs, _ls = _ax.get_legend_handles_labels()
                        _all_legend_handles += tuple(_hs)
                        _all_legend_labels += tuple(_ls)
            elif _result_array.ndim == 3:
                _nrows = _result_array.shape[1]
                _ncols = _result_array.shape[2]

                _fig, _gs = self._make_figure_gs(figsize=(8, 8), nrows=_nrows, ncols=_ncols)
                for _row in six.moves.range(_nrows):
                    for _col in six.moves.range(_ncols):
                        _plot_config_subplot = _plot_config.copy()
                        _plot_config_subplot['plot_xlabel'] = _plot_config_subplot['plot_xlabel'][_row, _col]
                        _ax = plt.subplot(_gs[_row, _col])
                        self._plot_hist(_ax, _result_array[:, _row, _col], **_plot_config_subplot)

                        # keep track of subplot legend handles/labels
                        if show_legend:
                            _hs, _ls = _ax.get_legend_handles_labels()
                            _all_legend_handles += tuple(_hs)
                            _all_legend_labels += tuple(_ls)
            else:
                raise FitEnsembleException("Cannot plot result for variable '%s': variable "
                                           "entry dimensionality too high (%d)!" % (_result_name, _result_array.ndim))

            if show_legend:
                # suppress multiple entries for the same label
                _hs = []
                _ls = []
                _seen_labels = set()
                for _h, _l in zip(_all_legend_handles, _all_legend_labels):
                    if _l not in _seen_labels:
                        _hs.append(_h)
                        _ls.append(_l)
                        _seen_labels.add(_l)

                _fig.legend(_hs, _ls, loc='lower center')
                _figure_extra_bottom = 0.05 * len(_ls)  # more space at figure bottom for legend
            else:
                _figure_extra_bottom = 0.0  # no extra space at figure bottom

            _gs.tight_layout(_fig,
                             pad=0.0, w_pad=0, h_pad=-0.2,
                             rect=(0.01, 0.02+_figure_extra_bottom, 0.98, 0.98))

        # TODO: maybe return something?

    RESULTS_PROPERTIES  = {'parameter_pulls': _parameter_pulls,
                           'y_data_pulls': _y_data_pulls,
                           'cost': _cost}
    RESULTS_SHAPE_SPECS = {'parameter_pulls': (n_par,),
                           'y_data_pulls': (n_dat,),
                           'cost': None}